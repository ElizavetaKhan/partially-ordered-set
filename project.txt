class orderedSet {
    // список ведущих
    struct Node {
        int key;        // ключ
        int* count{};   // количество предшественников
        Node* nexT{};   // следующий типа Node
        node* trail{};  // список узлов, для которых данный является ведомым

        Node(int key) {
            this->count = new int;
            this->key = key;
        }
    };

    // список ведомых
    struct node : public Node {
    // нет доступа к данным полям
    private:
        using Node::nexT;
        using Node::trail;

    public:
        node* next;
    };

private:
    Node* head;

private:
    // ищем в списке key, если не нашли – nullptr
    Node* findKey(int key);
        // проходим по списку от головы до nullptr
        // если уже есть такой key – возвращаем его
        // в конце просто возвращаем хвост, если ничего не нашли

    // получает key.next без предшественников, удаляется из списка ведущих и как предшественник у других узлов
    // если надо удалить голову – получает nullptr на вход
    void deletE(Node* key);
        // если нужно удалить голову
            // запоминаем элемент в cur
            // а голову перекидываем на next(если next нет – head = nullptr)
        // иначе
            // запоминаем элемент key.next в cur
            // если не последний элемент
                // key.next перекидываем на cur.next
            // иначе (если последний элемент)
                // key.next присваиваем nullptr

        // убираем теперь cur как предшественника из других узлов в цикле for идем по trailам
        deleteTrail(cur->trail);


    // возвращает PREV у первого встретившегося узла Node, не имеющего предшественников\
    // голову проверяем отдельно ДО этого метода
    // возвращает nullptr – когда больше нет элементов с count=0 (зацикливание)
    Node* noPrev();
        // храним prev
        // идем по списку от head.next до nullptr(до этого метода всегда проверяем голову отдельно)
            // если count == 0 – возвращаем prev
        // возвращаем nullptr(если зациклились)


    // можно ли вытащить голову? и есть ли она вообще?
    bool isHeadCount_0();
        // return head && head->count == 0;


    // деструктор для списка, который начали собирать, но случилось зацикливание
    static void destructor(Node* heaD);
        // идет по списку от heaD
        // запоминает next, удаляет cur и присваивает ему после удаления next


    // удаляет trail у узла, начиная с headTrail
    static void deleteTrail(node* headTrail);
        // циклом for идем от headTrail по списку до nullptr
            // вычитаем у каждого элемента count


public:
    orderedSet();

    ~orderedSet();
        // идет по списку пока current
            // подчищаем trails у current тоже в цикле(запоминая следующий элемент)
            // удаляем сам current
            // присваиваем currenty ранее запомненный next
        // this->head = nullptr;


    // передаем сразу пару
    void insert(int slaveKey, int leadingKey);
        // если головы еще нет – создаем
        // иначе идем в findKey() искать есть ли уже данный key
        // если оттуда вернулся другой key(хвост)
            // создаем новый элемент
            // вставляем его после вернувшегося хвоста
        // проделываем то же самое с ведущим узлом из пары
            // в findKey() ищем key
            // если не нашли – добавляем после вернувшегося хвоста

        // создаем узел, чтобы положить его в trail ведомого
            // если там пока ничего нет – просто закидываем новый trail
            // иначе идем по списку ведомых до конца ИЛИ пока не встретим такой же узел
                // если не нашли – добавляем в хвост
        // увеличиваем число предшественников у ведущего узла


    void makeOrderly();
        // ГОЛОВУ НОВОГО СПИСКА ЗАПОЛНЯЕМ ОТДЕЛЬНО
        // если у головы уже count = 0
            // удаляем head из текущего списка в методе deletE() и сдвигаем голову на next
            // двигаемся дальше (к следующему элементу без предшественников)
                // если у головы count = 0 – i = head
                // иначе i = noPrev()
        // иначе
            // i.next – первый встретившийся элемент без предшественников
            i = noPrev();
            // удаляем i.next как предшественника в deletE() и "вырезаем" из текущего списка
            // добавляем в новый список и сдвигаем curInNewList
            // двигаемся дальше (к следующему элементу без предшественников)
                // если у головы count = 0 – i = head
                // иначе i = noPrev()

        // РАБОТАЕМ С ОСТАЛЬНЫМИ ЭЛЕМЕНТАМИ СПИСКА
        // пока не зациклились или не кончились элементы в текущем списке
            // если у головы count = 0
                // кладем i в хвост нового списка
                // удаляем в методе delete голову старого списка и удаляем везде как предшественника
            // иначе
                // кладем i.next в хвост нового списка
                // "вырезаем" i.next в методе delete из старого списка и удаляем везде как предшественника
            // cur в новом списке сдвигаем к хвосту, также подчищаем у этого хвоста nextы

            // двигаемся дальше (к следующему элементу без предшественников)
                // если у головы count = 0 – i = head
                // иначе i = noPrev()


        // если зациклились и head есть – подчищаем память в новом списке
            destructor(newHead) и возвращаем false
        // если всё супер – присваиваем новую голову и возвращаем тру

    void print();
};